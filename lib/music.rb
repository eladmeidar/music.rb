# music.rb is symbolic musical computation for Ruby.
# Copyright (C) 2008 Jeremy Voorhis <jvoorhis@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

class Array
  def rand
    self[(Kernel::rand * size).floor]
  end
end

module Music
  
  # base 2 logarithm
  def self.log2(x)
    Math.log(x) / Math.log(2)
  end 
  
  # Convert midi note numbers to hertz
  def self.mtof(pitch)
    440.0 * (2 ** (((pitch)-69)/12))
  end
  
  # Convert hertz to midi note numbers
  def self.ftom(pitch)
    (69 + 12 * (log2(pitch / 440.0))).round
  end
  
  # Cast pitch value as a midi pitch number.
  def self.MidiPitch(pitch)
    case pitch
      when Integer then pitch 
      when Float then ftom(pitch)
      else raise ArgumentError, "Cannot cast #{pitch.class} to midi."
    end
  end
  
  # Cast pitch value as hertz.
  def self.Hertz(pitch)
    case pitch
      when Integer then mtof(pitch)
      when Float then pitch
      else raise ArgumentError, "Cannot cast #{pitch.class} to hertz."
    end
  end
  
  class PitchClass
    include Comparable
    
    def self.for(pitch)
      PITCH_CLASSES.detect { |pc| pc.ord == pitch % 12 }
    end
    
    attr_reader :name, :ord
    
    def initialize(name, ord)
      @name, @ord = name, ord
    end
    
    def <=>(pc) ord <=> pc.ord end
    
    def to_s; name.to_s end
    
    # Western pitch classes. Accidental note names borrowed from LilyPond.
    PITCH_CLASSES = [
      new(:c, 0), new(:cis, 1),
      new(:d, 2), new(:dis, 3),
      new(:e, 4),
      new(:f, 5), new(:fis, 6),
      new(:g, 7), new(:gis, 8),
      new(:a, 9), new(:ais, 10),
      new(:b, 11)
    ]
  end
  
  # +MusicStructure+
  class MusicStructure
    # Sequencing
    def >>(structure)
      @next = structure
    end
    
    def has_next?
      !@next.nil?
    end
    
    def next_structure; @next end
    
    # Return the next MusicStructure in its prepared state.
    def next
      @next.prepare if @next
    end
    
    # Prepare the structure before generating an event.
    def prepare; self end
    
    def generate(surface)
      raise NotImplementedError, "Subclass responsibility, #{self.class.name}"
    end
    
    def surface
      Surface.new(self)
    end
    
    def structure
      StructureIterator.new(self)
    end
  end
  
  # The crux of all MusicEvents: they can be performed. Subtypes of MusicEvent
  # share some common attributes: pitch, duration, effort. MusicEvent does not
  # require that those attributes be represented by any specific type, or even
  # the same type! What is important is that performers of MusicEvent have some
  # knowledge of the chosen types. For example, SMFPerformance will interpret
  # an Integer as a MIDI note number, and a Float will be interpreted as hertz.
  class MusicEvent
    # Call MusicEvent#perform with a performance visitor.
    def perform(performance)
      raise NotImplementedError, "Subclass responsibility"
    end
  end
  
  # A Surface arises from a MusicStructure.
  #
  # A Surface is a list of MusicEvents generated by traversing a MusicStructure.
  class Surface
    include Enumerable
    
    def initialize(head)
      @head    = head
      @surface = []
      generate
    end
    
    def [](key) @surface[key] end
    
    # Enumerate MusicEvents
    def each(&block) @surface.each(&block) end
    
    # Generate
    def generate
      @surface.clear
      return if @head.nil?
      cursor = @head.prepare
      
      begin
        @surface << cursor.generate(self)
      end while cursor = cursor.next
    end
  end
  
  class StructureIterator
    include Enumerable
    
    def initialize(head)
      @head = head
    end
    
    def each
      return if @head.nil?
      cursor = @head
      
      begin
        yield cursor
      end while cursor = cursor.next_structure
    end
  end
  
  # Remain silent for the duration.
  class Silence < MusicEvent
    attr :duration
    
    def initialize(duration)
      @duration = duration
    end
    
    def perform(performance)
      performance.play_silence(self)
    end
  end
  
  # A note has a steady pitch, a duration, and some amount of effort.
  class Note < MusicEvent
    attr_reader :pitch, :duration, :effort
    
    def initialize(pitch, duration, effort)
      @pitch, @duration, @effort = pitch, duration, effort
    end
    
    def perform(performance)
      performance.play_note(self)
    end
    
    def pitch_class
      PitchClass.for(@pitch)
    end
  end
  
  # A chord has multiple pitches, optionally with their own effort values. A
  # single duration is required.
  class Chord < MusicEvent
    attr_reader :pitches, :duration, :effort
    
    def initialize(pitches, duration, effort)
      @pitches, @duration, @effort = pitches, duration, effort
    end
    
    # Iterate over each pitch in the chord, with its corresponding effort value.
    def pitch_with_effort
      e = Array(effort)
      @pitches.each_with_index { |p, i| yield([p, e[i % e.size]]) }
    end
    
    def perform(performance)
      performance.play_chord(self)
    end
    
    def pitch_class
      @pitches.map { |pitch| PitchClass.for(pitch) }
    end
  end
  
  # Generate the given event.
  class Constant < MusicStructure
    def initialize(event)
      @event = event
    end
    
    def generate(surface) @event.dup end
  end
  
  # Choose randomly from given structures, then proceed.
  class Choice < MusicStructure
    attr :choices
    
    def initialize(*choices)
      @choices = choices
    end
    
    def prepare
      choice = @choices.rand
      unless choice.has_next?
        choice = choice.dup
        choice >> @next
      end
      choice.prepare
    end
  end
  
  # Alternate between the given structures.
  class Cycle < MusicStructure
    attr :structures
    
    def initialize(*structures)
      @structures = structures
      @pos = @structures.size
    end
    
    def prepare
      structure = @structures[ @pos %= @structures.size ]
      @pos += 1
      unless structure.has_next?
        structure = structure.dup
        structure >> @next
      end
      structure.prepare
    end
  end
  
  class Repeat < MusicStructure
    attr :structure
    
    def initialize(repititions, structure)
      @repititions, @structure = Integer(repititions), structure
    end
    
    def prepare
      if @repititions.zero?
        @next.prepare if @next
      else
        @repititions -= 1
        @structure.prepare
      end
    end
  end
  
  ::Kernel.module_eval do
    def silence(duration=128)
      Constant.new(Silence.new(duration))
    end
    alias :rest :silence
    
    def note(pitch, duration=128, effort=64)
      Constant.new(Note.new(pitch, duration, effort))
    end
    
    def chord(pitches, duration=128, effort=64)
      Constant.new(Chord.new(pitches, duration, effort))
    end
    
    def choice(*structures)
      Choice.new(*structures)
    end
    
    def cycle(*structures)
      Cycle.new(*structures)
    end
    
    def repeat(rep, structure)
      Repeat.new(rep, structure)
    end
  end
  
  require 'smf'
  
  # Standard Midi File performance.
  class SMFPerformance
    include SMF
    
    def initialize(surface, seq_name)
      @surface = surface
      @filename = seq_name + '.mid'
      @seq = Sequence.new
      @track = Track.new
      @seq << @track
      @track << SequenceName.new(0, seq_name)
      @channel = 1
      @offset = 0
    end
    
    def perform
      @surface.each { |event| event.perform(self) }
      self
    end
    
    def save
      @seq.save(@filename)
    end
    
    def play_silence(ev)
      @offset += ev.duration
    end
    
    def play_note(ev)
      @track << NoteOn.new(@offset, @channel, Music.MidiPitch(ev.pitch), ev.effort)
      @offset += ev.duration
      @track << NoteOff.new(@offset, @channel, Music.MidiPitch(ev.pitch), ev.effort)
    end
    
    def play_chord(ev)
      ev.pitch_with_effort do |pitch, effort|
        @track << NoteOn.new(@offset, @channel, Music.MidiPitch(pitch), effort)
      end
      @offset += ev.duration
      ev.pitch_with_effort do |pitch, effort|
        @track << NoteOff.new(@offset, @channel, Music.MidiPitch(pitch), effort)
      end
    end
  end
  
  require 'enumerator'
  require 'set'
  require 'graphviz'
  
  class DOT
    
    def initialize(start, name)
      @start = start
      @gv = GraphViz.new(name)
      graph!
    end
    
    def output; @gv.output end
    
    def graph!
      nodes, edges = Set[], Set[]
      @start.structure.each_cons 2 do |s1, s2|
        nodes.add(s1.object_id.to_s)
        nodes.add(s2.object_id.to_s)
        edges.add([s1.object_id.to_s,s2.object_id.to_s])
        
        case s1
        when Choice
          s1.choices.each do |choice|
            nodes.add(choice.object_id.to_s)
            edges.add([s1.object_id.to_s, choice.object_id.to_s])
            edges.add([choice.object_id.to_s, s1.next_structure.object_id.to_s])
          end
        when Cycle
          s1.structures.each do |structure|
            nodes.add(structure.object_id.to_s)
            edges.add([s1.object_id.to_s, structure.object_id.to_s])
          end
        when Repeat
          nodes.add(s1.structure.object_id.to_s)
          edges.add([s1.object_id.to_s, s1.structure.object_id.to_s])
        end
      end
      
      for node in nodes
        @gv.add_node(node)
      end
      
      for n1, n2 in edges
        @gv.add_edge(n1, n2)
      end
    end
  end
end

if __FILE__ == $0
  srand 0
  
  def example
    (lbl=note(60)) >>
      note(62) >>
      cycle(note(64), note(71)) >>
      choice(lbl, note(62)) >>
      repeat(3, lbl) >>
      chord([60, 67, 72], 256, [127, 72, 96])
    lbl
  end
  
  s = example.surface
  puts s.map { |note| note.pitch_class } * ', '
  
  Music::SMFPerformance.new(s, 'example').perform.save
end
